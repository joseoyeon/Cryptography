1. 문제제시
Feistel 암호 방식의 DES 암호 알고리즘을 설계 구현한다.


2. 순서도(입/출력, UI 설계는 생략)



- 편의상 입력은 문자로 받고, 출력은 2진수와 10진수로 한다.
- 각 단계의 과정을 볼 수 있도록 생성값들을 출력한다.
- 복호화의 순서도는 두번째 열부터 시작한다.

 

 

3. 소스코드(VS 2005로 코딩)

 

 

#define SIZE 8  // 64비트크기

 

#define ENCRYPTION 1  // 암호화, 복호화구분

#define DECRYPTION 0

 

int PC_1[(SIZE-1)*8] =  {57,49,41,33,25,17, 9,

                                                       1,58,50,42,34,26,18,

                                                      10, 2,59,51,43,35,27,

                                                      19,11, 3,60,52,44,36,

                                                      63,55,47,39,31,23,15,

                                                       7,62,54,46,38,30,22,

                                                      14, 6,61,53,45,37,29,

                                                      21,13, 5,28,20,12, 4};

 

int PC_2[(SIZE-2)*8] =  {14,17,11,24, 1, 5,

                                                       3,28,15, 6,21,10,

                                                      23,19,12, 4,26, 8,

                                                      16, 7,27,20,13, 2,

                                                      41,52,31,37,47,55,

                                                      30,40,51,45,33,48,

                                                      44,49,39,56,34,53,

                                                      46,42,50,36,29,32};

// 키생성시전치표PC-1, PC-2

 

int IP[(SIZE*8)] = {58, 50, 42, 34, 26 ,18 ,10, 2,

                                            60, 52, 44, 36, 28, 20, 12, 4,

                                            62, 54, 46, 38, 30, 22, 14, 6,

                                            64, 56, 48, 40, 32, 24, 16, 8,

                                            57, 49, 41, 33, 25, 17,  9, 1,

                                            59, 51, 43, 35, 27, 19, 11, 3,

                                            61, 53, 45, 37, 29, 21, 13, 5,

                                            63, 55, 47, 39, 31, 23, 15, 7};

 

int IP_invers[(SIZE*8)]= {40, 8, 48, 16, 56, 24, 64, 32,

                                                       39, 7, 47, 15, 55, 23, 63, 31,

                                                       38, 6, 46, 14, 54, 22, 62, 30,

                                                       37, 5, 45, 13, 53, 21, 61, 29,

                                                       36, 4, 44, 12, 52, 20, 60, 28,

                                                       35, 3, 43, 11, 51, 19, 59, 27,

                                                       34, 2, 42, 10, 50, 18, 58, 26,

                                                       33, 1, 41,  9, 49, 17, 57, 25};

// 평문전치시전치표IP, IP^-1

 

 

int E[SIZE*6] = {32, 1, 2, 3, 4, 5,

                                      4, 5, 6, 7, 8, 9,

                                      8, 9,10,11,12,13,

                                     12,13,14,15,16,17,

                                      16,17,18,19,20,21,

                                     20,21,22,23,24,25,

                                     24,25,26,27,28,29,

                                     28,29,30,31,32, 1};

 

int P[SIZE*4] = {16, 7,20,21,

                                     29,12,28,17,

                                      1,15,23,26,

                                      5,18,31,10,

                                      2, 8,24,14,

                                     32,27, 3, 9,

                                     19,13,30, 6,

                                     22,11, 4,25};

// 확대전치표E, 평행전치표P

 

int S_box[8][4][16] = {

         {//S1

                  {14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7},

                  {0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8},

                  {4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0},

                  {15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13}

         },

         {//S2

                  {15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10},

                  {3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5},

                  {0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15},

                  {13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9}

         },

         {//S3

                  {10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8},

                  {13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1},

                  {13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7},

                  {1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12}

         },

         {//S4

                  {7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15},

                  {13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9},

                  {10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4},

                  {3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14}

         },

         {//S5

                  {2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9},

                  {14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6},

                  {4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14},

                  {11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3}

         },

         {//S6

                  {12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11},

                  {10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8},

                  {9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6},

                  {4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13}

         },

         {//S7

                  {4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1},

                  {13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6},

                  {1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2},

                  {6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12}

         },

         {//S8

                  {13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7},

                  {1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2},

                  {7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8},

                  {2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11}

         }       

};

// S Box 표1~8

 

 

int LS = 1; // 키스케줄러LS(시프트횟수)  1라운드사용이므로하나만저장

 

void chartobinary(int *,char *c);  

void binarytochar(int *c,char *r);

int chartonum(int *,int size);

 

void input_word(char *,char *);

void print_binary(int *c,int size);

void print_char(char *c,int size);

 

void keygen(int *realk,int *k);

 

void permutation(int *c,int *t,int *ip);

void f_function(int *c,int *t,int *k,int des_state);

 

void des_main(char *,char *,char *,int des_state);

 

////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////

void main(){

 

         static char plaintext[SIZE];  // 입력받는64비트평문, VC 6.0에서첫문자를못읽어서static으로선언

         char key[SIZE];  // 입력받는64비트키

         char result[SIZE];  // 결과문자열

 

         input_word(plaintext,key);  // 평문과암호키입력

 

         des_main(plaintext,key,result,ENCRYPTION);  // 암호화작업(평문,키,결과(암호)문자열,암호화)

 

         des_main(result,key,plaintext,DECRYPTION);  // 복호화작업(암호문자,키,결과(평문)문자열,복호화)

 

         scanf("%s",key);

}

//////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////

 

 

void des_main(char *plaintext,char *key,char *result, int des_state){

 

         int binary_plaintext[SIZE*8];  // 이진평문

         int binary_cipher[SIZE*8];  // 이진암호문

         int binary_key[SIZE*8];  // 이진키

         int realkey[(SIZE-2)*8];  // 48비트실제키

 

         printf("\n///////////////////////////////\n");      

         if(des_state == ENCRYPTION)

                  printf("  작업내용: 암호화작업\n");

         else

                  printf("  작업내용: 복호화작업\n");

 

         printf("[출력] 입력한평문의2진변환\n");

         chartobinary(binary_plaintext,plaintext);

         print_binary(binary_plaintext,8); printf("\n");     

        

         printf("[출력] 입력한키의2진변환\n");

         chartobinary(binary_key,key);

         print_binary(binary_key,8);  printf("\n");

        

         printf("[출력] 생성한키의2진변환\n");

         keygen(realkey ,binary_key);

         print_binary(realkey,6); printf("\n");

         // 키생성

        

         printf("[출력] 초기전치한평문의2진변환\n");

         permutation(binary_cipher,binary_plaintext, IP);

         print_binary(binary_cipher,8);  printf("\n");

         // 초기전치

        

         printf("[출력] f함수적용평문의2진변환\n");

         f_function(binary_cipher ,binary_cipher, realkey,des_state);

         print_binary(binary_cipher,8);  printf("\n");

         // f함수적용(분리및합병포함)

        

         printf("[출력] 전치적용최종암호문의2진변환\n");

         permutation(binary_plaintext ,binary_cipher, IP_invers);

         print_binary(binary_plaintext,8);  printf("\n");

         // 전치적용최종암호문

 

         printf("[출력] 최종암호문의문자변환\n");

         binarytochar(binary_plaintext, result);   printf("\n");

         print_char(result,8);

         // 암호문을문자열로변환하여출력

}

 

void input_word(char *p, char *k){

         printf("///////////////////////////////\n");

         printf("[입력] 암호화하려는평문(64 bit) : ");

         scanf("%s",p);

         printf("[입력] 암호화시에사용할키(64 bit) : ");

         scanf("%s",k);

}

 

void f_function(int *c,int *t,int *k,int des_state){

 

         int lefttext[((SIZE)*4)];  // 평문분리한32비트임시평문

         int righttext[((SIZE)*4)];  // 평문분리한32비트임시평문

         int temptext[((SIZE)*6)];  // 확대전치적용시사용할48비트임시평문

         int temptext2[((SIZE)*4)];  // f함수적용시사용할32비트임시평문

         int temptext3[((SIZE)*4)];  // f함수적용시사용할32비트임시평문

 

         int i=0,j=0, tempnum=0, bit=0,a=0,count=0;

         int row[2], column[4];  // S_box 연산시사용할행과열값저장소

 

         if(des_state == ENCRYPTION){

                  for(i=0;i<(SIZE)*4;i++){

                           lefttext[i]=t[i];

                           righttext[i]=t[i+((SIZE)*4)];

                  }

         }else{

                  for(i=0;i<(SIZE)*4;i++){

                           lefttext[i]=t[i+((SIZE)*4)];

                           righttext[i]=t[i];

                  }

         }

         // 평문반으로분리

         // 암호화일경우그대로, 복호화일경우반대로분리

 

 

         {                 ///// f 함수진입

                  for(i=0;i<(SIZE)*6;i++){   // 평문righttext의비트값을확대전치(48 bit)                  

                           temptext[i] = righttext[E[i]-1];

                  }

 

                  for(i=0;i<(SIZE)*6;i++){  

                           temptext[i] = temptext[i] == k[i] ? 0 : 1;  // 키와평문을XOR 연산

                  }

 

                  for(i=0;i<8;i++){  // S_box 연산

                           row[1] = temptext[(i*6)];  // S_box 표의행값저장(b1,b6)

                           row[0] = temptext[(i*6)+5];

 

                           a=3;

                           for(j=0;j<4;j++){

                                   column[a--] = temptext[(i*6)+j+1];  // S_box 표의열값저장(b2~b5)

                           }

                           tempnum = S_box[i][chartonum(row,2)][chartonum(column,4)]; // S_box에서가져온수임시저장

 

                           bit=8;  // 1000

                           for(j=0;j<4;j++){  // 숫자를비트열로변환

                                   temptext2[count++] = (tempnum&bit) == bit ? 1 : 0;

                                   bit = bit >> 1;

                           }

                  }       

                 

                  for(i=0;i<(SIZE)*4;i++){  // 평문temptext2의비트값을표P에따라전치(32 bit)                       

                           temptext3[i] = temptext2[P[i]-1]; 

                  }

 

                  for(i=0;i<(SIZE)*4;i++){                            

                           lefttext[i] = lefttext[i] == temptext3[i] ? 0 : 1;

                           // 왼쪽평문과f함수출력값을XOR 연산

                  }

         }

 

         if(des_state == ENCRYPTION){

                  for(i=0;i<(SIZE)*4;i++){

                           c[i+((SIZE)*4)]=lefttext[i];

                           c[i]=righttext[i];                         

                  }       

         }else{

                  for(i=0;i<(SIZE)*4;i++){

                           c[i]=lefttext[i];

                           c[i+((SIZE)*4)]=righttext[i];                       

                  }       

         }

         // 분리한키병합

         // 암호화일경우그대로, 복호화일경우반대로병합

}

 

int chartonum(int *c,int size){  // 이진문자열을숫자로

         int i=0,j=0, num=0,num2=0;

         for(i=0;i<size;i++){

                  if(c[i]==1){

                           num2=1;

                           for(j=0;j<i;j++){  // pow함수로하려다오류나서바꿈

                                   num2 = num2*2;

                           }

                           num += num2;

                  }

         }

         return num;

}

 

void permutation(int *c,int *t,int *ip){

         int i=0;

        

         for(i=0;i<(SIZE)*8;i++){                   

                  c[i] = t[ip[i]-1]; // 입력받은평문t의비트값을전치(64 bit)

         }

}

 

void keygen(int *realk,int *k){

 

         int tempkey[(SIZE-1)*8];  // 56비트변환키

         int leftkey[((SIZE-1)*4)+1];  // 변환키분리한28비트임시키

         int rightkey[((SIZE-1)*4)+1];  // 변환키분리한28비트임시키

 

         int i=0, j=0;

 

         for(i=0;i<(SIZE-1)*8;i++){ // 입력받은키k의비트값을PC-1에따라축약전치(56 bit)           

                  tempkey[i] = k[PC_1[i]-1];

         }       

 

         for(i=0;i<(SIZE-1)*4;i++){  // 키반으로분리

                  leftkey[i]=tempkey[i];

                  rightkey[i]=tempkey[i+((SIZE-1)*4)];

         }       

 

         for(i=0;i<LS;i++){  // LS 수만큼회전

                  leftkey[((SIZE-1)*4)] = leftkey[0];  // 로테이트위해첫번째비트를마지막비트에백업

                  rightkey[((SIZE-1)*4)] = rightkey[0];

                  for(j=0;j<(SIZE-1)*4;j++){

                           leftkey[j] = leftkey[j+1];

                           rightkey[j] = rightkey[j+1];

                  }

         }

 

         for(i=0;i<(SIZE-1)*4;i++){

                  tempkey[i]=leftkey[i];

                  tempkey[i+((SIZE-1)*4)]=rightkey[i];

         }

         // 분리한키병합

 

         for(i=0;i<(SIZE-2)*8;i++){  // 병합한키k의비트값을PC-2에따라축약전치(48 bit)

                  realk[i] = tempkey[PC_2[i]-1];

         }

}

 

void print_binary(int *c, int size){ // 이진문자열출력

         int i=0;

         for(i=1;i<(SIZE*size)+1;i++){

                  printf("%d",c[i-1]);

                  if((i%8) == 0)  // 8비트마다칸내림

                           printf("\n");

         }

}

 

void print_char(char *c,int size){

         int i=0;

         for(i=0;i<size;i++){

                  printf("%c ",c[i]);

         }

         printf("\n");

}

 

void chartobinary(int *b,char *c){  // 문자열을이진문자열로변환

         int i=0, j=0, k=0;

         int bit=0;

 

         for(i=0;i<SIZE;i++){

                  bit = 128; // 10000000

                 

                  for(j=0;j<8;j++){

                           b[(i*8)+j] = (c[i]&bit) == bit ? 1 : 0;                      

                           bit = bit >> 1;

                  }

         }

}

 

void binarytochar(int *c,char *r){  // 이진문자열을문자열로변환하여출력

         int i=0,j=0,k=0,temp=0,count=0;

 

         for(i=0;i<8;i++){  // 문자열넣을저장소초기화

                  r[i]=0;

         }

 

         for(i=0;i<8;i++){

                  count=8; 

                  for(j=0;j<8;j++){

                           count--;

                           if(c[(i*8)+j]== 1){

                                   temp=1;

                                   for(k=0;k<count;k++)

                                            temp *=2;

                                   r[i] +=temp;  // 비트추가

                           }

                  }

         }

}

 


 
4. 출력결과


  

 

5. 검증(결과값은 4. 출력결과를 참조)

 

u  입력한 평문의 2진 변환 및 출력(유니코드로 변환)

 

        2진변환 함수 : chartobinary(binary_plaintext,plaintext);

        출력 함수 : print_binary(binary_plaintext,8); printf("\n"); 

 

-입력 : blackout

-출력 및 검증

b = 98 = 01100010,        l = 108 = 01101100,        a = 97 = 01100001,        c = 99 = 01100011

k = 107 = 01101011,       o = 111 = 01101111,       u = 117 = 01110101,    t = 116 = 01110100

 

-결과 : 모든 문자 올바르게 변환 및 출력(이후의 변환은 검증 생략)

 

u  키 생성

 

키 생성 함수 : keygen(realkey ,binary_key);

 

-입력 : goodlife의 2진 변환

-출력 및 검증

 

키 스케줄러에 따라 첫 연산은 축약전치이다. 입력한 키를 2진 변환 값은

 

01100111          01101111          01101111          01100100         

01101100          01101001          01100110          01100101

 

이고 치환표 PC-1에 따라 치환하면

 

00000000          11111111          11111111          00000100

01111101          11110011          01100000

 

 Goodlife의 2진 변환 배열을 K라 하고 K를 PC-1에 따라 치환 연산한 배열을 P_K라 하고 임의로 정한 배열번호 1, 2, 10을 검증한다. PC-1 표에 따라 K 배열의 57번에 저장되어있는 데이터는 P_K 배열의 1번에 저장되어야 한다. 마찬가지로 49번은 2, 50번은 10이므로 각 배열번호에 해당하는 배열값들을 확인하면,

 

K[57] = 0, P_K[1] = 0 -> 성립

K[49] = 0, P_K[2] = 0 -> 성립

K[50] = 1, P_K[10] = 1 -> 성립

으로 성립한다

 다음연산은 비트열을 반으로 나눈 후 LS에 따라 시프트연산을 하는 것이다. 비트열을 반으로 나누면,

 

Left  : 00000000            11111111          11111111          0000

Right : 01000111            11011111          00110110          0000

 

이고, LS=1이므로 두 비트열에 1회전연산을 하면

 

0000000           11111111          11111111          00000

1000111           11011111          00110110          00000

 

이다.

 

다시 두 비트열을 병합하고(K),

00000001          11111111          11111110          00001000

11111011          11100110          11000000

 

PC-2로 축약전치 하면(P_K)

11100000          10111110          01100110          10011001

00100110          10111110

 

이고, PC-2표에 따라 위와 같은 방법으로 확인하면

K[14] = 1, P_K[1] = 1 -> 성립

K[17] = 1, P_K[2] = 1 -> 성립

K[6] = 0, P_K[10] = 0 -> 성립

으로 성립한다.

 

결과 : 출력키와 비교하여 같으므로 올바른 키 생성

 

u  초기전치, 역전치

 

전치함수 : permutation(binary_cipher,binary_plaintext, IP);

 

-입력 : 평문의 2진 변환과 IP 전치표

-출력 및 검증

 

 평문의 2진 변환 비트열을 IP 전치표에 따라 치환한다. blackout을 이진 비트열로 변환하면,

 

01100010          01101100          01100001          01100011

01101011          01101111          01110101          01110100

 

이고(K) 전치표 IP에 따라 전치 하면(P_K)

 

11111111          11000000          11100010          01111100

00000000          11111111          00110010          00111001

 

IP표에 따라 위와 같은 방법으로 확인하면

K[58] = 1, P_K[1] = 1 -> 성립

K[50] = 1, P_K[2] = 1 -> 성립

K[52] = 1, P_K[10] = 1 -> 성립

으로 성립한다.

 

결과 : 올바르게 전치된다. (이후의 역전치 IP^-1은 검증생략)

 

u  f함수 연산

 

f 함수 :f_function(binary_cipher ,binary_plaintext, realkey);

 

-입력 : 초기전치 한 평문과 키 생성으로 만들어진 키

-출력 및 검증

 

먼저 평문을 반으로 나누고 오른쪽 비트열을 확대전치한다. 비트열을 반으로 나누면,

 

Left  : 11111111            11000000          11100010          01111100

Right : 00000000            11111111          00110010          00111001

 

이고 오른쪽 비트열을 전치표 E에 따라서 확대전치하면

 

10000000          00010111          11111110          10110000

11000011          10101010

 

이다. (검증 생략) 다음으로 생성된 키와 XOR 연산을 한다. 앞의 8비트만 직접 해보면

 

Right 비트열  :  10000000

생성키 비트열 : 11100000

XOR 연산 -------------

             01100000

 

으로 성립한다.

 

 다음 단계에서는 S_box를 이용해 48비트의 연산결과값을 32비트로 변환한다. 현재까지의 연산결과값은

 

01100000          10101001          10011000          00000011          01100111          01001100

 

이고 역시 6비트만 직접 계산하여 검증한다.

 

첫번째 비트열에서 011000 에서 b1b6은 00이고 b2b3b4b5은 1100이다. 이것은 10진수로 변환하면 0, 12이므로 S1_box에서 행렬 (0, 12)의 좌표값은 5이다. (0부터 시작) 5를 2진수로 표현하면 0101 이므로 결과값과 같다.

 

다음으로 치환표 P에 따라 결과값을 치환한다. 현재 결과 비트열은

 

01011011          10011011          00101010          10001011

 

이고 치환표 P에 따라 치환하면

 

11011100          01101010          11001001          11000011

 

마지막으로 결과 비트열을 처음에 평문으로부터 나누어진 왼쪽 비트열과 XOR 연산하여 오른쪽 비트열로 저장하고, 오른쪽 비트열은 왼쪽 비트열로 교차하여 저장한다.

 

앞의 8비트만 XOR 연산을 해보면

Left 비트열  :     11111111

결과 비트열  :    11011100

XOR 연산 -------------

00100011

 

으로 성립하고, 양쪽 비트열을 교차하여 병합하면

 

00000000          11111111          00110010          00111001         

00100011          10101010          00101011          10111111

 

으로 f 함수연산이 종료된다.

 

결과 : f 함수 연산이 올바르게 실행됨

 

 

 

u  암호화 최종결과

 마지막으로 결과 비트열에 역전치 IP^-1을 최종 암호 비트열이 완성된다. 역전치는 위에 검증한 전치연산과 치환표를 제외하고 같은 방식으로 이루어지기 때문에 생략한다. 최종 결과 비트열은

 

10011011          10111110          00010010          00111011

00010111          10111111          00010000          00110010

 

이고 문자로 변환하면( 4. 출력결과 참조)

 

?? ; ?2

 

이다.

 

u  복호화 최종결과

 암호화와 복호화의 연산은 분해와 합병순서를 제외하고 같다. 암호화 과정에서 초기전치(IP) 후 왼쪽, 오른쪽 비트열로 나누었던 암호문은 왼쪽 비트열이 오른쪽으로, 오른쪽 비트열이 왼쪽으로 엇갈려 저장되는데, 복호화 과정에서는 초기전치(IP) 후 오른쪽 비트열이 왼쪽으로, 왼쪽 비트열이 오른쪽으로 엇갈려 저장된다. 간단히 말해 암호화 시에 뒤집어 놓은 문자열을 원래대로 정렬한다. (구현내용은 3. 코드소스 에서 참조)

 

복호화의 최종결과 비트열은

 

01100010          01101100          01100001          01100011

01101011          01101111          01110101          01110100

 

이고 문자로 변환하면

 

b l a c k o u t

 

이다. 이것은 처음에 입력하였던 평문과 일치한다.

 

6. 정리

연산자체가 워낙 복잡해서 검증시에 생략한 곳이 많다. 또한 모든 비트 연산시에 정수형 배열에 비트열을 저장하여 사용했는데, 처음엔 실제 비트연산으로 알고리즘을 구현해보려 했지만 전치와 S_box 적용시에(사실상 전부) 구현에 어려움이 있어서 배열로 구현했다.

 
[출처] Simple DES algorithm|작성자 방가